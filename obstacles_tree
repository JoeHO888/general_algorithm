import matplotlib.pyplot as plt
import numpy as np
import math

mutation_rate=0.01
crossover_rate=0.8
pop_size=100
generation=50
DNA_length=12
step=1
starting_pt=[0,0]
obstacle=[[3,-5,1],[7,-1,12]]


#def fitness(pop):
#       #return abs(sum(np.sin(pop).T))
#      return sum(np.cos(pop).T)**2+sum(np.sin(pop).T)**2

def fitness(pop,start=[0,0],obstacle=[],step=1):
    result=[]
    whole_x=[]
    whole_y=[]
    for e in pop:
        element_x=[]
        element_y=[]
        current_x = start[0]
        current_y = start[1]
        element_x.append(current_x)
        element_y.append(current_y)
        for i in range(DNA_length):
            next_x = current_x + step*math.cos(e[i])
            next_y = current_y + step*math.sin(e[i])
            for bar in obstacle:
                if hit(current_x,current_y,next_x,next_y,bar):
                    slope = (next_y - current_y) /(next_x - current_x)
                    next_y = bar[0]
                    next_x = current_x+((next_y - current_y)/slope)
            current_x=next_x
            current_y=next_y
            element_x.append(current_x)
            element_y.append(current_y)
        if current_y-start[1]<0:
            result.append(step)
        else:
            result.append(current_y-start[1])
        whole_x.append(element_x)
        whole_y.append(element_y)
    return [np.array(result), whole_x, whole_y]

def hit(current_x,current_y,next_x,next_y,obstacle):
    if current_y <= obstacle[0] and next_y > obstacle[0]:
        if obstacle[1]<=current_x <=obstacle[2]:
            return True
    return False
    


def select(pop,start=[0,0],obstacle=[],step=1):
    score=fitness(pop,start,obstacle,step)[0]
    index=np.random.choice(pop_size, pop_size, replace=True,p=score/score.sum()) #problematic
    return np.array([pop[i] for i in index]) 


def crossover(dad,pop): 
        for i in range(len(dad)):
            if np.random.uniform(0,1,1)<crossover_rate:
                crosspoint=np.random.randint(0,DNA_length,size=1)[0]
                j=np.random.randint(0,pop_size,size=1)[0]
                dad[i,crosspoint:]=pop[j,crosspoint:]
        return dad

def mutate(pop):
        for e in pop:
            for i in range(DNA_length):
                  if np.random.uniform(0,1,1)<mutation_rate:
                        e[i]=np.random.uniform(-math.pi,math.pi)
        return pop


population=np.random.uniform(-math.pi,math.pi,size=(pop_size, DNA_length))


for gen in range(generation):
    dad = select(population,starting_pt,obstacle,step)
    children = crossover(dad,population)
    population = mutate(children)
    f = fitness(population,starting_pt,obstacle,step)
    score = f[0]
    print("Best one of generation {}:".format(gen+1))
    best = population[np.argmax(score)]
    #print(best)
    print("fitness: " + str(max(score)))
    #axes = plt.gca()
    #axes.set_xlim([-DNA_length*step+starting_pt[0],DNA_length*step+starting_pt[0]])
    #axes.set_ylim([-DNA_length*step+starting_pt[1],DNA_length*step+starting_pt[1]])
    plt.figure(figsize=(20,10))
    plt.plot([obstacle[0][1],obstacle[0][2]],[obstacle[0][0],obstacle[0][0]],linewidth=1)
    plt.plot([obstacle[1][1],obstacle[1][2]],[obstacle[1][0],obstacle[1][0]],linewidth=1)
    plt.plot(f[1][np.argmax(score)],f[2][np.argmax(score)],linewidth=1)
    plt.show() 
    
    
